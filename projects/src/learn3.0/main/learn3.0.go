package main

/*  第三章，基本数据

 */
import "fmt"

func main() {
	// intFunc()
	// calFunc()
	compareFunc()
}

/*  整数
 Go 同时具备有符号整数和无符号整数。 有符号整数分 四种大小： 8位，16位，32位，64位，
用 int8, int16, int32, int64 表示， 对应的无符号整数是 uint8, uint16, uint32, uint64。

此外还有 两种类型 int 和 uint。在特定平台上，其大小与原生的有符号整数\无符号整数相同，
或等于该平台上的运算效率最高的值。这两种类型大小相等，都是 32位或 64位，但不能认为它们
一定就是 32位，或一定就是 64位；
即使在同样的硬件平台上，不同的编译器可能选用不同的大小。

rune 类型是 int32类型的同义词。
byte 类型是 uint8类型的同义词。

最后，还有一种无符号整数 uintptr, 其大小并不明确，但足以完整存放指针。
uintptr 类型仅仅用于底层编程，例如在 Go 程序与C 程序库或操作系统的接口界面。

int, uint 和 uintptr 都有别于其大小明确的相似类型的类型。
就是说， int 和 int32 是不同类型，尽管 int 天然的大小就是 32位，
并且 int 值若要当做 int32使用，必须显式转换；反之亦然。

 */
func intFunc(){

	/*  取值范围
	有符号整数以 补码表示，保留最高位作为符号位， n 位数字的取值范围是 -2^(n-1) ~ 2^(n-1) -1 。
	例如 : int8 的取值范围： -2^(n-1) ~ 2^(n-1) -1  == -2^(8-1) ~ 2^(8-1) -1  == -128 ~ 127
	无符号整数由全部位构成其非负值， 范围是 0~2^n -1。
	例如 : uint8 的取值范围： 0~2^n -1 == 0~2^8 -1 == 0~255
	 */

	/*
		不论是有符号数还是无符号数，若表示算术运算结果所需的位 超出该类型的范围，就称为 溢出。
		溢出的高位部分会 无提示地丢弃。
	 */

	// uint8 取值范围为： 0~255
	var u uint8 = 255
	fmt.Println(u, u+1, u*u)  // "255 0 1"

	var p = u+10
	// 把运算分割为 p = 255+1+9 = 0+9 = 9
	fmt.Println(p)  // "9"

	// uint8 取值范围为： 0~255
	var j uint8 = 255
	fmt.Println(j, j-255-1, j*j)  // "255 255 1"
	// 运算分割  j-255-1 = 255-255-1 = 0-1 = 255  (粗暴的理解：又一个轮回)

	var k = j+255
	// 把运算分割为 k = 255+255 = 255+1+254 = 254
	fmt.Println(k)  // "254"


	// int8 取值范围为： -128~127
	var i int8 = 127
	fmt.Println(i, i+1, i*i) // "127 -128 1"

	var f = i+10
	fmt.Println(f) // "-119"
	// 解析： f = 127+10, 由于 i 的取值范围为 -128~127，所以已经超过了它的范围，
	//所以把运算分割为 f = 127+1+9 = -128+9 = -119

	/*
		 那么，我们能不能修改 f 的取值范围呢？ 尝试  var f int16 = i+10 ,
		 但是编译错误， 因为 i 为 int8 类型，int16与int8属于不同类型的声明，所以编译报错
	 */

	/*
		那么，我们再次尝试将 i+10 的 int8类型的变量，强制转换为 int16 呢，会不会有用？
		编译没有报错，但是运行结果 依然是 一样的  -119

		var m int16 = int16(i+10)
		fmt.Println(m) // "-119"
	 */

	// int8 取值范围为： -128~127
	/*
		var n = m + 128   // 编译报错,报错信息 : constant 128 overflows int8
		 128 这个数值已经溢出 int8 的取值范围，所以不能进行运算符，但是可以有以下方法，
		var n = m + 127 + 1
	*/
	var m int8 = 127
	// 分拆 m+127+1 = 127+127+1 = 127+(-128) = -1
	fmt.Println(m, m+127+1, m*-3) // "127 -1 -125"
	// 分拆 m*-3 = -(m*3) = -(127+127+127) = -(127+1+127+1+125) = -(-128+127+1+125) = -125
	var n = m+127+1
	fmt.Println(n) // "-1"

}

// 上例中的 m*m  为什么会等于1 , 溢出的高位部分会无提示地丢弃。 到底是什么意思？？
// 二元运算符
/*
	Go的二元操作符涵盖了算术， 逻辑，和比较等运算。按优先级的降序排列如下：
	*   /   %   <<   >>   &   &^
	+   -   |   ^
	==  !=  <   <=   >   >=
	&&
	||
 */

func calFunc(){
	var x int = 5
	var y int = 2
	var a float64 = 5.0
	var b float64 = 2.0
	var i int = -5
	var j int = -2

	/*
	算术运算符 + ，- ，* ， / 可应用于整数，浮点数 和复数，
		知识点： 而取模运算符 % 仅能 用于整数，如下例：

		知识点： 就 Go而言， 取模余数的 正负号 总是与被除数一致， （ % 前面是 被除数， %后面是除数）
		5%2， 与 5%-2 结果都是 1 ， 结果的正负号 与 被除数 5 一致，所以为 正
	 */

	fmt.Printf("int x除以 int y取余： %d\n", x%y)  // "1"， 编译正确
	// fmt.Println(a%b) //编译报错： invalid operation : a%b (operator % not defined on float64)

	fmt.Printf("int x除以 int j(负数) 取余： %d\n", x%j)  // "1"， 编译正确

	/*
		知识点： 除法运算(/)的行为 取决于操作数是否都为 整型， 整数相除，商会舍弃小数部分，
		于是：  5.0/2.0 == 2.5  , 5/2 == 2
	 */
	fmt.Printf("float a除以 float b取整： %v\n", a/b)  // "2.5"， 编译正确
	fmt.Printf("int x除以 int y取整： %d\n", x/y)  // "2"， 编译正确

	/*
		知识点： 除法运算(/)的结果的 正负号 与 平常算术题一致，有一方为 负，则为负
	 */
	fmt.Printf("int x除以 int j(负数)取整： %d\n", x/j)  // "-2"， 编译正确
	fmt.Printf("int i(负数)除以 int y取整： %d\n", i/y)  // "-2"， 编译正确
	fmt.Printf("int i(负数)除以 int j(负数)取整： %d\n", i/j)  // "2"， 编译正确

}

// 比较运算符
/*
	下列二元比较运算符用于比较两个类型相同的整数； 比较表达式本身的类型是 布尔型。
	== 等于
	!= 不等于
	<   小于
	<=  小于或等于
	>   大于
	>=  大于等于

	实际上，全部基本类型的值（布尔值，数值，字符串）都可以比较，这意味着两个相同类型的值可用 == 和 ！= 运算符比较。
	整数，浮点数 和 字符串还能根据比较 运算符排序。 许多其他类型的值是不可比较的，也无法排序。
 */

/*
	另外，还有 一元加法 和 一元减法运算符：
	+    一元取正 （无实际影响）
	-    一元取负
	对于整数， +x 是 0+x 的简写， 而 -x 则为 0-x 的简写。
	对于浮点数和 复数， +x 就是 x, -x 为 x 的复数。
 */

func compareFunc(){

	var x int = 5
	var a float64 = 5.0
	var i int = -5
	var k float64 = -5.0

	// 对于整数而言， +x 是 0+x 的简写, 而 -x 则为 0-x的简写。
	fmt.Printf("-x : %d\n", -x) // "-5" , 0-5 == -5
	fmt.Printf("-i : %d\n", -i) // "5",  0-(-5) == 5

	// 对于浮点数 和 复数(后面章节会讲到), +x 就是 指 x, -x 则为 x 的负数
	fmt.Printf("-a : %f\n", -a)  // "-5.0", a 的负数， 5.0的负数为 -5.0
	fmt.Printf("-k : %f\n", -k)  // "5.0", k 的负数， -5.0的负数为 5.0

}


