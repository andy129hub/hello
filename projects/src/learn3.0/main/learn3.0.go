package main

/*  第三章，基本数据

 */
import "fmt"

func main() {
	intFunc()
}

/*  整数
 Go 同时具备有符号整数和无符号整数。 有符号整数分 四种大小： 8位，16位，32位，64位，
用 int8, int16, int32, int64 表示， 对应的无符号整数是 uint8, uint16, uint32, uint64。

此外还有 两种类型 int 和 uint。在特定平台上，其大小与原生的有符号整数\无符号整数相同，
或等于该平台上的运算效率最高的值。这两种类型大小相等，都是 32位或 64位，但不能认为它们
一定就是 32位，或一定就是 64位；
即使在同样的硬件平台上，不同的编译器可能选用不同的大小。

rune 类型是 int32类型的同义词。
byte 类型是 uint8类型的同义词。

最后，还有一种无符号整数 uintptr, 其大小并不明确，但足以完整存放指针。
uintptr 类型仅仅用于底层编程，例如在 Go 程序与C 程序库或操作系统的接口界面。

int, uint 和 uintptr 都有别于其大小明确的相似类型的类型。
就是说， int 和 int32 是不同类型，尽管 int 天然的大小就是 32位，
并且 int 值若要当做 int32使用，必须显式转换；反之亦然。

 */
func intFunc(){

	/*  取值范围
	有符号整数以 补码表示，保留最高位作为符号位， n 位数字的取值范围是 -2^(n-1) ~ 2^(n-1) -1 。
	例如 : int8 的取值范围： -2^(n-1) ~ 2^(n-1) -1  == -2^(8-1) ~ 2^(8-1) -1  == -128 ~ 127
	无符号整数由全部位构成其非负值， 范围是 0~2^n -1。
	例如 : uint8 的取值范围： 0~2^n -1 == 0~2^8 -1 == 0~255
	 */

	/*
		不论是有符号数还是无符号数，若表示算术运算结果所需的位 超出该类型的范围，就称为 溢出。
		溢出的高位部分会 无提示地丢弃。
	 */

	// uint8 取值范围为： 0~255
	var u uint8 = 255
	fmt.Println(u, u+1, u*u)  // "255 0 1"

	var p = u+10
	// 把运算分割为 p = 255+1+9 = 0+9 = 9
	fmt.Println(p)  // "9"

	// uint8 取值范围为： 0~255
	var j uint8 = 255
	fmt.Println(j, j-255-1, j*j)  // "255 255 1"
	// 运算分割  j-255-1 = 255-255-1 = 0-1 = 255  (粗暴的理解：又一个轮回)

	var k = j+255
	// 把运算分割为 k = 255+255 = 255+1+254 = 254
	fmt.Println(k)  // "254"


	// int8 取值范围为： -128~127
	var i int8 = 127
	fmt.Println(i, i+1, i*i) // "127 -128 1"

	var f = i+10
	fmt.Println(f) // "-119"
	// 解析： f = 127+10, 由于 i 的取值范围为 -128~127，所以已经超过了它的范围，
	//所以把运算分割为 f = 127+1+9 = -128+9 = -119

	/*
		 那么，我们能不能修改 f 的取值范围呢？ 尝试  var f int16 = i+10 ,
		 但是编译错误， 因为 i 为 int8 类型，int16与int8属于不同类型的声明，所以编译报错
	 */

	/*
		那么，我们再次尝试将 i+10 的 int8类型的变量，强制转换为 int16 呢，会不会有用？
		编译没有报错，但是运行结果 依然是 一样的  -119

		var m int16 = int16(i+10)
		fmt.Println(m) // "-119"
	 */

	// int8 取值范围为： -128~127
	/*
		var n = m + 128   // 编译报错,报错信息 : constant 128 overflows int8
		 128 这个数值已经溢出 int8 的取值范围，所以不能进行运算符，但是可以有以下方法，
		var n = m + 127 + 1
	*/
	var m int8 = 127
	// 分拆 m+127+1 = 127+127+1 = 127+(-128) = -1
	fmt.Println(m, m+127+1, m*-3) // "127 -1 -125"
	// 分拆 m*-3 = -(m*3) = -(127+127+127) = -(127+1+127+1+125) = -(-128+127+1+125) = -125
	var n = m+127+1
	fmt.Println(n) // "-1"

}

// 上例中的 m*m  为什么会等于1 , 溢出的高位部分会无提示地丢弃。 到底是什么意思？？
// 二元运算符
func calFunc(){

}

