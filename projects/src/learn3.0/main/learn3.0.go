package main

/*  第三章，基本数据

 */
import "fmt"

func main() {
	// intFunc()
	// calFunc()
	// compareFunc()
	// offsetFunc()
	// testIntForIndex()
	// typeConvertFunc()
	OXconvertFunc()
}

/*  整数
 Go 同时具备有符号整数和无符号整数。 有符号整数分 四种大小： 8位，16位，32位，64位，
用 int8, int16, int32, int64 表示， 对应的无符号整数是 uint8, uint16, uint32, uint64。

此外还有 两种类型 int 和 uint。在特定平台上，其大小与原生的有符号整数\无符号整数相同，
或等于该平台上的运算效率最高的值。这两种类型大小相等，都是 32位或 64位，但不能认为它们
一定就是 32位，或一定就是 64位；
即使在同样的硬件平台上，不同的编译器可能选用不同的大小。

rune 类型是 int32类型的同义词。
byte 类型是 uint8类型的同义词。

最后，还有一种无符号整数 uintptr, 其大小并不明确，但足以完整存放指针。
uintptr 类型仅仅用于底层编程，例如在 Go 程序与C 程序库或操作系统的接口界面。

int, uint 和 uintptr 都有别于其大小明确的相似类型的类型。
就是说， int 和 int32 是不同类型，尽管 int 天然的大小就是 32位，
并且 int 值若要当做 int32使用，必须显式转换；反之亦然。

 */
func intFunc(){

	/*  取值范围
	有符号整数以 补码表示，保留最高位作为符号位， n 位数字的取值范围是 -2^(n-1) ~ 2^(n-1) -1 。
	例如 : int8 的取值范围： -2^(n-1) ~ 2^(n-1) -1  == -2^(8-1) ~ 2^(8-1) -1  == -128 ~ 127
	无符号整数由全部位构成其非负值， 范围是 0~2^n -1。
	例如 : uint8 的取值范围： 0~2^n -1 == 0~2^8 -1 == 0~255
	 */

	/*
		不论是有符号数还是无符号数，若表示算术运算结果所需的位 超出该类型的范围，就称为 溢出。
		溢出的高位部分会 无提示地丢弃。
	 */

	// uint8 取值范围为： 0~255
	var u uint8 = 255
	fmt.Println(u, u+1, u*u)  // "255 0 1"

	var p = u+10
	// 把运算分割为 p = 255+1+9 = 0+9 = 9
	fmt.Println(p)  // "9"

	// uint8 取值范围为： 0~255
	var j uint8 = 255
	fmt.Println(j, j-255-1, j*j)  // "255 255 1"
	// 运算分割  j-255-1 = 255-255-1 = 0-1 = 255  (粗暴的理解：又一个轮回)

	var k = j+255
	// 把运算分割为 k = 255+255 = 255+1+254 = 254
	fmt.Println(k)  // "254"


	// int8 取值范围为： -128~127
	var i int8 = 127
	fmt.Println(i, i+1, i*i) // "127 -128 1"

	var f = i+10
	fmt.Println(f) // "-119"
	// 解析： f = 127+10, 由于 i 的取值范围为 -128~127，所以已经超过了它的范围，
	//所以把运算分割为 f = 127+1+9 = -128+9 = -119

	/*
		 那么，我们能不能修改 f 的取值范围呢？ 尝试  var f int16 = i+10 ,
		 但是编译错误， 因为 i 为 int8 类型，int16与int8属于不同类型的声明，所以编译报错
	 */

	/*
		那么，我们再次尝试将 i+10 的 int8类型的变量，强制转换为 int16 呢，会不会有用？
		编译没有报错，但是运行结果 依然是 一样的  -119

		var m int16 = int16(i+10)
		fmt.Println(m) // "-119"
	 */

	// int8 取值范围为： -128~127
	/*
		var n = m + 128   // 编译报错,报错信息 : constant 128 overflows int8
		 128 这个数值已经溢出 int8 的取值范围，所以不能进行运算符，但是可以有以下方法，
		var n = m + 127 + 1
	*/
	var m int8 = 127
	// 分拆 m+127+1 = 127+127+1 = 127+(-128) = -1
	fmt.Println(m, m+127+1, m*-3) // "127 -1 -125"
	// 分拆 m*-3 = -(m*3) = -(127+127+127) = -(127+1+127+1+125) = -(-128+127+1+125) = -125
	var n = m+127+1
	fmt.Println(n) // "-1"

}

// 上例中的 m*m  为什么会等于1 , 溢出的高位部分会无提示地丢弃。 到底是什么意思？？
// 二元运算符
/*
	Go的二元操作符涵盖了算术， 逻辑，和比较等运算。按优先级的降序排列如下：
	*   /   %   <<   >>   &   &^
	+   -   |   ^
	==  !=  <   <=   >   >=
	&&
	||
 */

func calFunc(){
	var x int = 5
	var y int = 2
	var a float64 = 5.0
	var b float64 = 2.0
	var i int = -5
	var j int = -2

	/*
	算术运算符 + ，- ，* ， / 可应用于整数，浮点数 和复数，
		知识点： 而取模运算符 % 仅能 用于整数，如下例：

		知识点： 就 Go而言， 取模余数的 正负号 总是与被除数一致， （ % 前面是 被除数， %后面是除数）
		5%2， 与 5%-2 结果都是 1 ， 结果的正负号 与 被除数 5 一致，所以为 正
	 */

	fmt.Printf("int x除以 int y取余： %d\n", x%y)  // "1"， 编译正确
	// fmt.Println(a%b) //编译报错： invalid operation : a%b (operator % not defined on float64)

	fmt.Printf("int x除以 int j(负数) 取余： %d\n", x%j)  // "1"， 编译正确

	/*
		知识点： 除法运算(/)的行为 取决于操作数是否都为 整型， 整数相除，商会舍弃小数部分，
		于是：  5.0/2.0 == 2.5  , 5/2 == 2
	 */
	fmt.Printf("float a除以 float b取整： %v\n", a/b)  // "2.5"， 编译正确
	fmt.Printf("int x除以 int y取整： %d\n", x/y)  // "2"， 编译正确

	/*
		知识点： 除法运算(/)的结果的 正负号 与 平常算术题一致，有一方为 负，则为负
	 */
	fmt.Printf("int x除以 int j(负数)取整： %d\n", x/j)  // "-2"， 编译正确
	fmt.Printf("int i(负数)除以 int y取整： %d\n", i/y)  // "-2"， 编译正确
	fmt.Printf("int i(负数)除以 int j(负数)取整： %d\n", i/j)  // "2"， 编译正确

}

// 比较运算符
/*
	下列二元比较运算符用于比较两个类型相同的整数； 比较表达式本身的类型是 布尔型。
	== 等于
	!= 不等于
	<   小于
	<=  小于或等于
	>   大于
	>=  大于等于

	实际上，全部基本类型的值（布尔值，数值，字符串）都可以比较，这意味着两个相同类型的值可用 == 和 ！= 运算符比较。
	整数，浮点数 和 字符串还能根据比较 运算符排序。 许多其他类型的值是不可比较的，也无法排序。
 */

/*
	另外，还有 一元加法 和 一元减法运算符：
	+    一元取正 （无实际影响）
	-    一元取负
	对于整数， +x 是 0+x 的简写， 而 -x 则为 0-x 的简写。
	对于浮点数和 复数， +x 就是 x, -x 为 x 的复数。
 */

func compareFunc(){

	var x int = 5
	var a float64 = 5.0
	var i int = -5
	var k float64 = -5.0

	// 对于整数而言， +x 是 0+x 的简写, 而 -x 则为 0-x的简写。
	fmt.Printf("-x : %d\n", -x) // "-5" , 0-5 == -5
	fmt.Printf("-i : %d\n", -i) // "5",  0-(-5) == 5

	// 对于浮点数 和 复数(后面章节会讲到), +x 就是 指 x, -x 则为 x 的负数
	fmt.Printf("-a : %f\n", -a)  // "-5.0", a 的负数， 5.0的负数为 -5.0
	fmt.Printf("-k : %f\n", -k)  // "5.0", k 的负数， -5.0的负数为 5.0

	// 字符串之间的比较
	var s string = "abc"
	var str string = "abc "
	fmt.Printf(" s == str %t\n", s == str) // "false"

	// 布尔值之间的比较
	var b bool = false
	var bo bool    // 未赋值时默认为  false
	fmt.Printf(" b == bo %t\n", b == bo) // "true"
}

// 位运算符
/*
	Go也具备下列位运算符， 前四个对操作数的运算 逐位独立进行， 不涉及算术进位或 正负号；
	&   位运算 AND
	|   位运算 OR
	^   位运算 XOR
	&^  位清空 (AND NOT)
	<<  左移
	>>  右移
 */

/*
	如果作为二元运算符， 运算符 ^ 表示按位 “异或”(XOR); 若作为一元前缀运算符，
	则它表示按位取反 或 按位取补， 运算结果就是操作数逐位取反。 运算符 &^ 是按位清除（AND NOT）；
	表达式 z=x&^y 中，若 y 的某位是 1， 则 z 的对应位等于 0; 否则，它就等于 x 的对应位。
 */

/*
	下面的代码说明了 如何用位 运算 将一个 uint8 值作为位集(bitset)处理，其含有8个独立的位，
	高效且紧凑。 Printf 用谓词 %b 以二进制形式输出数值， 副词 08在这个输出结果前 被(补)零，补够8 位。

	在移位运算 x<<n 和 x>>n 中，操作数 n 决定位移量，而且 n 必须为无符号型；
	操作数 x 可以是有符号型 也可以是 无符号型。算术上， 左移运算 x<<n 等价于 x 乘以 2^n;
	而右移运算 x>>n 等价于 x 除以 2^n，向下取整。
 */
func offsetFunc(){
	var x uint8 = 1<<1 | 1<<5
	var y uint8 = 1<<1 | 1<<2
	// %08b 可以理解为 以八进制打印
	fmt.Printf("%08b\n", x) // "00100010" ，集合 {1,5}
	fmt.Printf("%08b\n", y) // "00000110" ，集合 {1,2}

	fmt.Printf("%08b\n", x&y)  // "00000010" ，交集 {1}
	fmt.Printf("%08b\n", x|y)  // "00100110" ，并集 {1,2,5}
	fmt.Printf("%08b\n", x^y)  // "00100100" ，对称差 {2,5}
	fmt.Printf("%08b\n", x&^y) // "00100000" ，差集 {5}

	for i:= uint(0); i<8; i++ {
		if x&(1<<i) != 0 { // 元素判定
			fmt.Println(i) // "1" , "5"
		}
	}

	fmt.Printf("%08b\n", x<<1) // "01000100" ，集合{2,6}
	fmt.Printf("%08b\n", x>>1) // "00010001" ，集合{0,4}
}
/*
	左移以 0 填补右边空位，无符号整数右移 同样以 0 填补左边空位，但有符号数的右移操作是按 符号位的值填补空位。
	因此， 请注意，如果将整数以位模式处理， 须使用无符号整型。
 */

/*
	尽管Go 具备无符号整型数和 相关算术运算，也尽管某些量值不可能为负， 但是我们往往还采用有符号整型数，
	如数组的长度（即便直观上明显更应该选用 uint）。下列从后向前输出奖牌名称，循环里用到了内置的 len 函数，
	它返回有符号整数：
 */

func testIntForIndex(){
	medals := []string{"gold","silver","bronze"}
	for i:= len(medals) - 1; i>=0;i-- {
		/*
			问： 一般来说，数组的长度不可能为负，所以 直观上应该将 i 定义为一个 无符号类型 uint,
			但这里为什么用的还是 int  (len(medals) 返回 int 型)？？？
			答： 假若  len 返回的结果是无符号整数，就会导致严重错误， 因为 i 随之也成为 uint 型，
				根据定义，条件 i>=0 将恒成立。
			第3轮迭代后， 有 i==0， 语句 i-- 使得 i 变为 uint型的最大值（例如，可能位 2的64次方-1），而不是 -1，
			这就导致了 medals[i] 试图越界访问元素，超出 slice 范围，引发运行失败或 宕机.
		 */
		fmt.Println(medals[i])  // "bronze", "silver", "gold"
	}
}

/*
	位运算符使用总结：
		1，无符号整数往往只用于 位运算符和 特定算术运算符， 如实现位集时，解析二进制格式的文件，或 散列和加密。
			一般而言，无符号整数极少用于表示非负值。
 */

/*
	通常，将某种类型的值转换成另一种， 需要显式转换。对于算术和逻辑（不含位移）的二元运算符，其操作数的类型必须相同。
	虽然这有时会导致表达式相对冗长，但是一整类错误得以避免，程序也更容易理解。
 */
func typeConvertFunc(){
	var apples int32 = 1
	var oranges int16 = 2

	// var compote int = apples + oranges  // 编译错误， apples 与 oranges 类型不匹配

	// 类型不匹配的问题 有几种方法改正， 最直接地，将全部操作数转换成 同一类型：
	var compote = int(apples) +  int(oranges)   // 强制转换为 int
	fmt.Println(compote)  // "3"

	/*
		整型与浮点型 之间的转换，可能改变值或 损失精度
	 */

	f:= 3.141
	i:= int(f)
	fmt.Println(f,i) // "3.141 3"
	f = 1.99
	fmt.Println(int(f))  // "1"

	/*
		浮点型转成 整型， 会舍弃小数部分， 趋零截尾(正值向下取整， 负值向上取整)。
		如果有些转换的操作数的值超出了 目标类型的取值范围，就应当避免这种转换，
		因为其行为依赖具体实现：
	 */

	a:= 1e100   // float64 类型
	b:= int(f)  // 应当避免这种强制转换
	fmt.Println(a,b)
}

/*
	不论有无大小和符号限制， 源码中的整数都能写成常见的十进制数； 也能写成 八进制数，以 0 开头，如 0666；
	还能写成十六进制数， 以 0x 或 0X 开头， 如 0xdeadbeef 。
	十六进制的数字 (或字母)大小写皆可。 当前，八进制数似乎仅有一种用途 ---- 表示 POSIX 文件系统的权限 ---
	而十六进制数广泛用于强调其位模式，而非数值大小。
 */
func OXconvertFunc(){

	a := 0666   // 八进制
	/*
		一般来说，一个转义符对应一个要打印的变量，那为什么下面 有三个转义符 %d, %[1]o, %#[1]o ，却只有一个 变量 a
		说明：  注意 fmt 的两个技巧。 通常 Printf 的格式化字符串含有多个 %谓词， 这要求提供相同数目的操作数，
			而 % 后的副词 [1]告知 Printf 重复使用第一个操作数，也就是重复使用 a 这个操作数。
			其次，%o, %x, 或 %X 之前的副词 # 告知 Printf 输出对应的 前缀 0, 0x 或 0X
	 */
	fmt.Printf("%d %[1]o %#[1]o\n", a)   // "438 666 0666"
	b := int64(0xdeadbeef)  // 将 16进制强制转换为 int64
	fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", b) // "3735928559 deadbeef 0xdeadbeef 0XDEADBEEF

}